# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)  # noqa: E501

    The version of the OpenAPI document: 1.0.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""


from __future__ import annotations
from inspect import getfullargspec
import pprint
import re  # noqa: F401
import json



from pydantic import BaseModel, Field
from graph_api.models.relations_entity_happenedafter import RelationsEntityHAPPENEDAFTER

class RelationsEntity(BaseModel):
    """
    RelationsEntity
    """
    happened_after: RelationsEntityHAPPENEDAFTER = Field(..., alias="HAPPENED_AFTER")
    led_to: RelationsEntityHAPPENEDAFTER = Field(..., alias="LED_TO")
    affected: RelationsEntityHAPPENEDAFTER = Field(..., alias="AFFECTED")
    includes: RelationsEntityHAPPENEDAFTER = Field(..., alias="INCLUDES")
    occurred_in: RelationsEntityHAPPENEDAFTER = Field(..., alias="OCCURRED_IN")
    has_relationship: RelationsEntityHAPPENEDAFTER = Field(..., alias="HAS_RELATIONSHIP")
    participated_in: RelationsEntityHAPPENEDAFTER = Field(..., alias="PARTICIPATED_IN")
    contains: RelationsEntityHAPPENEDAFTER = Field(..., alias="CONTAINS")
    __properties = ["HAPPENED_AFTER", "LED_TO", "AFFECTED", "INCLUDES", "OCCURRED_IN", "HAS_RELATIONSHIP", "PARTICIPATED_IN", "CONTAINS"]

    class Config:
        allow_population_by_field_name = True
        validate_assignment = True

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.dict(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> RelationsEntity:
        """Create an instance of RelationsEntity from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self):
        """Returns the dictionary representation of the model using alias"""
        _dict = self.dict(by_alias=True,
                          exclude={
                          },
                          exclude_none=True)
        # override the default output from pydantic by calling `to_dict()` of happened_after
        if self.happened_after:
            _dict['HAPPENED_AFTER'] = self.happened_after.to_dict()
        # override the default output from pydantic by calling `to_dict()` of led_to
        if self.led_to:
            _dict['LED_TO'] = self.led_to.to_dict()
        # override the default output from pydantic by calling `to_dict()` of affected
        if self.affected:
            _dict['AFFECTED'] = self.affected.to_dict()
        # override the default output from pydantic by calling `to_dict()` of includes
        if self.includes:
            _dict['INCLUDES'] = self.includes.to_dict()
        # override the default output from pydantic by calling `to_dict()` of occurred_in
        if self.occurred_in:
            _dict['OCCURRED_IN'] = self.occurred_in.to_dict()
        # override the default output from pydantic by calling `to_dict()` of has_relationship
        if self.has_relationship:
            _dict['HAS_RELATIONSHIP'] = self.has_relationship.to_dict()
        # override the default output from pydantic by calling `to_dict()` of participated_in
        if self.participated_in:
            _dict['PARTICIPATED_IN'] = self.participated_in.to_dict()
        # override the default output from pydantic by calling `to_dict()` of contains
        if self.contains:
            _dict['CONTAINS'] = self.contains.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: dict) -> RelationsEntity:
        """Create an instance of RelationsEntity from a dict"""
        if obj is None:
            return None

        if type(obj) is not dict:
            return RelationsEntity.parse_obj(obj)

        _obj = RelationsEntity.parse_obj({
            "happened_after": RelationsEntityHAPPENEDAFTER.from_dict(obj.get("HAPPENED_AFTER")) if obj.get("HAPPENED_AFTER") is not None else None,
            "led_to": RelationsEntityHAPPENEDAFTER.from_dict(obj.get("LED_TO")) if obj.get("LED_TO") is not None else None,
            "affected": RelationsEntityHAPPENEDAFTER.from_dict(obj.get("AFFECTED")) if obj.get("AFFECTED") is not None else None,
            "includes": RelationsEntityHAPPENEDAFTER.from_dict(obj.get("INCLUDES")) if obj.get("INCLUDES") is not None else None,
            "occurred_in": RelationsEntityHAPPENEDAFTER.from_dict(obj.get("OCCURRED_IN")) if obj.get("OCCURRED_IN") is not None else None,
            "has_relationship": RelationsEntityHAPPENEDAFTER.from_dict(obj.get("HAS_RELATIONSHIP")) if obj.get("HAS_RELATIONSHIP") is not None else None,
            "participated_in": RelationsEntityHAPPENEDAFTER.from_dict(obj.get("PARTICIPATED_IN")) if obj.get("PARTICIPATED_IN") is not None else None,
            "contains": RelationsEntityHAPPENEDAFTER.from_dict(obj.get("CONTAINS")) if obj.get("CONTAINS") is not None else None
        })
        return _obj

